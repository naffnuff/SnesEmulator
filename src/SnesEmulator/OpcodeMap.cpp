#include "OpcodeMap.h"

#include <stdint.h>

#include "Opcode.h"
#include "State.h"

Instruction* OpcodeMap::getInstruction(uint8_t code) const
{
    return instructions[code].get();
}

OpcodeMap::OpcodeMap()
{
    instructions[0x61] = std::make_unique<Opcode::ADC_61>("ADC (dp,X)", "ADC Add With Carry [Flags affected: n,v,z,c]", "Direct Page Indexed Indirect, X");
    instructions[0x63] = std::make_unique<Opcode::ADC_63>("ADC sr,S", "ADC Add With Carry [Flags affected: n,v,z,c]", "Stack Relative");
    instructions[0x65] = std::make_unique<Opcode::ADC_65>("ADC dp", "ADC Add With Carry [Flags affected: n,v,z,c]", "Direct Page");
    instructions[0x67] = std::make_unique<Opcode::ADC_67>("ADC [dp]", "ADC Add With Carry [Flags affected: n,v,z,c]", "Direct Page Indirect Long");
    instructions[0x69] = std::make_unique<Opcode::ADC_69>("ADC #const", "ADC Add With Carry [Flags affected: n,v,z,c]", "Immediate");
    instructions[0x6D] = std::make_unique<Opcode::ADC_6D>("ADC addr", "ADC Add With Carry [Flags affected: n,v,z,c]", "Absolute");
    instructions[0x6F] = std::make_unique<Opcode::ADC_6F>("ADC long", "ADC Add With Carry [Flags affected: n,v,z,c]", "Absolute Long");
    instructions[0x71] = std::make_unique<Opcode::ADC_71>("ADC (dp),Y", "ADC Add With Carry [Flags affected: n,v,z,c]", "Direct Page Indirect Indexed, Y");
    instructions[0x72] = std::make_unique<Opcode::ADC_72>("ADC (dp)", "ADC Add With Carry [Flags affected: n,v,z,c]", "Direct Page Indirect");
    instructions[0x73] = std::make_unique<Opcode::ADC_73>("ADC (sr,S),Y", "ADC Add With Carry [Flags affected: n,v,z,c]", "Stack Relative Indirect Indexed, Y");
    instructions[0x75] = std::make_unique<Opcode::ADC_75>("ADC dp,X", "ADC Add With Carry [Flags affected: n,v,z,c]", "Direct Page Indexed,X");
    instructions[0x77] = std::make_unique<Opcode::ADC_77>("ADC [dp],Y", "ADC Add With Carry [Flags affected: n,v,z,c]", "Direct Page Indirect Long Indexed, Y");
    instructions[0x79] = std::make_unique<Opcode::ADC_79>("ADC addr,Y", "ADC Add With Carry [Flags affected: n,v,z,c]", "Absolute Indexed,Y");
    instructions[0x7D] = std::make_unique<Opcode::ADC_7D>("ADC addr,X", "ADC Add With Carry [Flags affected: n,v,z,c]", "Absolute Indexed,X");
    instructions[0x7F] = std::make_unique<Opcode::ADC_7F>("ADC long,X", "ADC Add With Carry [Flags affected: n,v,z,c]", "Absolute Long Indexed, X");
    instructions[0x21] = std::make_unique<Opcode::AND_21>("AND (dp,X)", "AND AND Accumulator With Memory [Flags affected: n,z]", "Direct Page Indexed Indirect, X");
    instructions[0x23] = std::make_unique<Opcode::AND_23>("AND sr,S", "AND AND Accumulator With Memory [Flags affected: n,z]", "Stack Relative");
    instructions[0x25] = std::make_unique<Opcode::AND_25>("AND dp", "AND AND Accumulator With Memory [Flags affected: n,z]", "Direct Page");
    instructions[0x27] = std::make_unique<Opcode::AND_27>("AND [dp]", "AND AND Accumulator With Memory [Flags affected: n,z]", "Direct Page Indirect Long");
    instructions[0x29] = std::make_unique<Opcode::AND_29>("AND #const", "AND AND Accumulator With Memory [Flags affected: n,z]", "Immediate");
    instructions[0x2D] = std::make_unique<Opcode::AND_2D>("AND addr", "AND AND Accumulator With Memory [Flags affected: n,z]", "Absolute");
    instructions[0x2F] = std::make_unique<Opcode::AND_2F>("AND long", "AND AND Accumulator With Memory [Flags affected: n,z]", "Absolute Long");
    instructions[0x31] = std::make_unique<Opcode::AND_31>("AND (dp),Y", "AND AND Accumulator With Memory [Flags affected: n,z]", "Direct Page Indirect Indexed, Y");
    instructions[0x32] = std::make_unique<Opcode::AND_32>("AND (dp)", "AND AND Accumulator With Memory [Flags affected: n,z]", "Direct Page Indirect");
    instructions[0x33] = std::make_unique<Opcode::AND_33>("AND (sr,S),Y", "AND AND Accumulator With Memory [Flags affected: n,z]", "Stack Relative Indirect Indexed, Y");
    instructions[0x35] = std::make_unique<Opcode::AND_35>("AND dp,X", "AND AND Accumulator With Memory [Flags affected: n,z]", "Direct Page Indexed, X");
    instructions[0x37] = std::make_unique<Opcode::AND_37>("AND [dp],Y", "AND AND Accumulator With Memory [Flags affected: n,z]", "Direct Page Indirect Long Indexed, Y");
    instructions[0x39] = std::make_unique<Opcode::AND_39>("AND addr,Y", "AND AND Accumulator With Memory [Flags affected: n,z]", "Absolute Indexed, Y");
    instructions[0x3D] = std::make_unique<Opcode::AND_3D>("AND addr,X", "AND AND Accumulator With Memory [Flags affected: n,z]", "Absolute Indexed, X");
    instructions[0x3F] = std::make_unique<Opcode::AND_3F>("AND long,X", "AND AND Accumulator With Memory [Flags affected: n,z]", "Absolute Long Indexed, X");
    instructions[0x06] = std::make_unique<Opcode::ASL_06>("ASL dp", "ASL Accumulator or Memory Shift Left [Flags affected: n,z,c]", "Direct Page");
    instructions[0x0A] = std::make_unique<Opcode::ASL_0A>("ASL A", "ASL Accumulator or Memory Shift Left [Flags affected: n,z,c]", "Accumulator");
    instructions[0x0E] = std::make_unique<Opcode::ASL_0E>("ASL addr", "ASL Accumulator or Memory Shift Left [Flags affected: n,z,c]", "Absolute");
    instructions[0x16] = std::make_unique<Opcode::ASL_16>("ASL dp,X", "ASL Accumulator or Memory Shift Left [Flags affected: n,z,c]", "Direct Page Indexed, X");
    instructions[0x1E] = std::make_unique<Opcode::ASL_1E>("ASL addr,X", "ASL Accumulator or Memory Shift Left [Flags affected: n,z,c]", "Absolute Indexed, X");
    instructions[0x90] = std::make_unique<Opcode::BCC_90>("BCC nearlabel", "BCC Branch if Carry Clear [Flags affected: none][Alias: BLT]", "Program Counter Relative");
    instructions[0xB0] = std::make_unique<Opcode::BCS_B0>("BCS nearlabel", "BCS Branch if Carry Set [Flags affected: none][Alias: BGE]", "Program Counter Relative");
    instructions[0xF0] = std::make_unique<Opcode::BEQ_F0>("BEQ nearlabel", "BEQ Branch if Equal [Flags affected: none]", "Program Counter Relative");
    instructions[0x24] = std::make_unique<Opcode::BIT_24>("BIT dp", "BIT Test Bits [Flags affected: z (immediate mode) n,v,z (non-immediate modes)]", "Direct Page");
    instructions[0x2C] = std::make_unique<Opcode::BIT_2C>("BIT addr", "BIT Test Bits [Flags affected: z (immediate mode) n,v,z (non-immediate modes)]", "Absolute");
    instructions[0x34] = std::make_unique<Opcode::BIT_34>("BIT dp,X", "BIT Test Bits [Flags affected: z (immediate mode) n,v,z (non-immediate modes)]", "Direct Page Indexed, X");
    instructions[0x3C] = std::make_unique<Opcode::BIT_3C>("BIT addr,X", "BIT Test Bits [Flags affected: z (immediate mode) n,v,z (non-immediate modes)]", "Absolute Indexed, X");
    instructions[0x89] = std::make_unique<Opcode::BIT_89>("BIT #const", "BIT Test Bits [Flags affected: z (immediate mode) n,v,z (non-immediate modes)]", "Immediate");
    instructions[0x30] = std::make_unique<Opcode::BMI_30>("BMI nearlabel", "BMI Branch if Minus [Flags affected: none]", "Program Counter Relative");
    instructions[0xD0] = std::make_unique<Opcode::BNE_D0>("BNE nearlabel", "BNE Branch if Not Equal [Flags affected: none]", "Program Counter Relative");
    instructions[0x10] = std::make_unique<Opcode::BPL_10>("BPL nearlabel", "BPL Branch if Plus [Flags affected: none]", "Program Counter Relative");
    instructions[0x80] = std::make_unique<Opcode::BRA_80>("BRA nearlabel", "BRA Branch Always [Flags affected: none]", "Program Counter Relative");
    instructions[0x00] = std::make_unique<Opcode::BRK_00>("BRK", "BRK Break [Flags affected: b,i (6502) b,d,i (65C02/65816 Emulation) d,i (65816 Native)]", "Stack/Interrupt");
    instructions[0x82] = std::make_unique<Opcode::BRL_82>("BRL label", "BRL Branch Long Always [Flags affected: none]", "Program Counter Relative Long");
    instructions[0x50] = std::make_unique<Opcode::BVC_50>("BVC nearlabel", "BVC Branch if Overflow Clear [Flags affected: none]", "Program Counter Relative");
    instructions[0x70] = std::make_unique<Opcode::BVS_70>("BVS nearlabel", "BVS Branch if Overflow Set [Flags affected: none]", "Program Counter Relative");
    instructions[0x18] = std::make_unique<Opcode::CLC_18>("CLC", "CLC Clear Carry [Flags affected: c]", "Implied");
    instructions[0xD8] = std::make_unique<Opcode::CLD_D8>("CLD", "CLD Clear Decimal Mode Flag [Flags affected: d]", "Implied");
    instructions[0x58] = std::make_unique<Opcode::CLI_58>("CLI", "CLI Clear Interrupt Disable Flag [Flags affected: i]", "Implied");
    instructions[0xB8] = std::make_unique<Opcode::CLV_B8>("CLV", "CLV Clear Overflow Flag [Flags affected: v]", "Implied");
    instructions[0xC1] = std::make_unique<Opcode::CMP_C1>("CMP (dp,X)", "CMP Compare Accumulator With Memory [Flags affected: n,z,c]", "Direct Page Indexed Indirect,X");
    instructions[0xC3] = std::make_unique<Opcode::CMP_C3>("CMP sr,S", "CMP Compare Accumulator With Memory [Flags affected: n,z,c]", "Stack Relative");
    instructions[0xC5] = std::make_unique<Opcode::CMP_C5>("CMP dp", "CMP Compare Accumulator With Memory [Flags affected: n,z,c]", "Direct Page");
    instructions[0xC7] = std::make_unique<Opcode::CMP_C7>("CMP [dp]", "CMP Compare Accumulator With Memory [Flags affected: n,z,c]", "Direct Page Indirect Long");
    instructions[0xC9] = std::make_unique<Opcode::CMP_C9>("CMP #const", "CMP Compare Accumulator With Memory [Flags affected: n,z,c]", "Immediate");
    instructions[0xCD] = std::make_unique<Opcode::CMP_CD>("CMP addr", "CMP Compare Accumulator With Memory [Flags affected: n,z,c]", "Absolute");
    instructions[0xCF] = std::make_unique<Opcode::CMP_CF>("CMP long", "CMP Compare Accumulator With Memory [Flags affected: n,z,c]", "Absolute Long");
    instructions[0xD1] = std::make_unique<Opcode::CMP_D1>("CMP (dp),Y", "CMP Compare Accumulator With Memory [Flags affected: n,z,c]", "Direct Page Indirect Indexed, Y");
    instructions[0xD2] = std::make_unique<Opcode::CMP_D2>("CMP (dp)", "CMP Compare Accumulator With Memory [Flags affected: n,z,c]", "Direct Page Indirect");
    instructions[0xD3] = std::make_unique<Opcode::CMP_D3>("CMP (sr,S),Y", "CMP Compare Accumulator With Memory [Flags affected: n,z,c]", "Stack Relative Indirect Indexed,Y");
    instructions[0xD5] = std::make_unique<Opcode::CMP_D5>("CMP dp,X", "CMP Compare Accumulator With Memory [Flags affected: n,z,c]", "Direct Page Indexed, X");
    instructions[0xD7] = std::make_unique<Opcode::CMP_D7>("CMP [dp],Y", "CMP Compare Accumulator With Memory [Flags affected: n,z,c]", "Direct Page Indirect Long Indexed, Y");
    instructions[0xD9] = std::make_unique<Opcode::CMP_D9>("CMP addr,Y", "CMP Compare Accumulator With Memory [Flags affected: n,z,c]", "Absolute Indexed, Y");
    instructions[0xDD] = std::make_unique<Opcode::CMP_DD>("CMP addr,X", "CMP Compare Accumulator With Memory [Flags affected: n,z,c]", "Absolute Indexed, X");
    instructions[0xDF] = std::make_unique<Opcode::CMP_DF>("CMP long,X", "CMP Compare Accumulator With Memory [Flags affected: n,z,c]", "Absolute Long Indexed, X");
    instructions[0x02] = std::make_unique<Opcode::COP_02>("COP const", "COP Co-Processor Enable [Flags affected: d,i]", "Stack/Interrupt");
    instructions[0xE0] = std::make_unique<Opcode::CPX_E0>("CPX #const", "CPX Compare Index Register X with Memory [Flags affected: n,z,c]", "Immediate");
    instructions[0xE4] = std::make_unique<Opcode::CPX_E4>("CPX dp", "CPX Compare Index Register X with Memory [Flags affected: n,z,c]", "Direct Page");
    instructions[0xEC] = std::make_unique<Opcode::CPX_EC>("CPX addr", "CPX Compare Index Register X with Memory [Flags affected: n,z,c]", "Absolute");
    instructions[0xC0] = std::make_unique<Opcode::CPY_C0>("CPY #const", "CPY Compare Index Register Y with Memory [Flags affected: n,z,c]", "Immediate");
    instructions[0xC4] = std::make_unique<Opcode::CPY_C4>("CPY dp", "CPY Compare Index Register Y with Memory [Flags affected: n,z,c]", "Direct Page");
    instructions[0xCC] = std::make_unique<Opcode::CPY_CC>("CPY addr", "CPY Compare Index Register Y with Memory [Flags affected: n,z,c]", "Absolute");
    instructions[0x3A] = std::make_unique<Opcode::DEC_3A>("DEC A", "DEC Decrement [Flags affected: n,z]", "Accumulator");
    instructions[0xC6] = std::make_unique<Opcode::DEC_C6>("DEC dp", "DEC Decrement [Flags affected: n,z]", "Direct Page");
    instructions[0xCE] = std::make_unique<Opcode::DEC_CE>("DEC addr", "DEC Decrement [Flags affected: n,z]", "Absolute");
    instructions[0xD6] = std::make_unique<Opcode::DEC_D6>("DEC dp,X", "DEC Decrement [Flags affected: n,z]", "Direct Page Indexed, X");
    instructions[0xDE] = std::make_unique<Opcode::DEC_DE>("DEC addr,X", "DEC Decrement [Flags affected: n,z]", "Absolute Indexed, X");
    instructions[0xCA] = std::make_unique<Opcode::DEX_CA>("DEX", "DEX Decrement Index Register X [Flags affected: n,z]", "Implied");
    instructions[0x88] = std::make_unique<Opcode::DEY_88>("DEY", "DEY Decrement Index Register Y [Flags affected: n,z]", "Implied");
    instructions[0x41] = std::make_unique<Opcode::EOR_41>("EOR (dp,X)", "EOR Exclusive-OR Accumulator with Memory [Flags affected: n,z]", "Direct Page Indexed Indirect,X");
    instructions[0x43] = std::make_unique<Opcode::EOR_43>("EOR sr,S", "EOR Exclusive-OR Accumulator with Memory [Flags affected: n,z]", "Stack Relative");
    instructions[0x45] = std::make_unique<Opcode::EOR_45>("EOR dp", "EOR Exclusive-OR Accumulator with Memory [Flags affected: n,z]", "Direct Page");
    instructions[0x47] = std::make_unique<Opcode::EOR_47>("EOR [dp]", "EOR Exclusive-OR Accumulator with Memory [Flags affected: n,z]", "Direct Page Indirect Long");
    instructions[0x49] = std::make_unique<Opcode::EOR_49>("EOR #const", "EOR Exclusive-OR Accumulator with Memory [Flags affected: n,z]", "Immediate");
    instructions[0x4D] = std::make_unique<Opcode::EOR_4D>("EOR addr", "EOR Exclusive-OR Accumulator with Memory [Flags affected: n,z]", "Absolute");
    instructions[0x4F] = std::make_unique<Opcode::EOR_4F>("EOR long", "EOR Exclusive-OR Accumulator with Memory [Flags affected: n,z]", "Absolute Long");
    instructions[0x51] = std::make_unique<Opcode::EOR_51>("EOR (dp),Y", "EOR Exclusive-OR Accumulator with Memory [Flags affected: n,z]", "Direct Page Indirect Indexed, Y");
    instructions[0x52] = std::make_unique<Opcode::EOR_52>("EOR (dp)", "EOR Exclusive-OR Accumulator with Memory [Flags affected: n,z]", "Direct Page Indirect");
    instructions[0x53] = std::make_unique<Opcode::EOR_53>("EOR (sr,S),Y", "EOR Exclusive-OR Accumulator with Memory [Flags affected: n,z]", "Stack Relative Indirect Indexed, Y");
    instructions[0x55] = std::make_unique<Opcode::EOR_55>("EOR dp,X", "EOR Exclusive-OR Accumulator with Memory [Flags affected: n,z]", "Direct Page Indexed, X");
    instructions[0x57] = std::make_unique<Opcode::EOR_57>("EOR [dp],Y", "EOR Exclusive-OR Accumulator with Memory [Flags affected: n,z]", "Direct Page Indirect Long Indexed, Y");
    instructions[0x59] = std::make_unique<Opcode::EOR_59>("EOR addr,Y", "EOR Exclusive-OR Accumulator with Memory [Flags affected: n,z]", "Absolute Indexed, Y");
    instructions[0x5D] = std::make_unique<Opcode::EOR_5D>("EOR addr,X", "EOR Exclusive-OR Accumulator with Memory [Flags affected: n,z]", "Absolute Indexed, X");
    instructions[0x5F] = std::make_unique<Opcode::EOR_5F>("EOR long,X", "EOR Exclusive-OR Accumulator with Memory [Flags affected: n,z]", "Absolute Long Indexed,X");
    instructions[0x1A] = std::make_unique<Opcode::INC_1A>("INC A", "INC Increment [Flags affected: n,z]", "Accumulator");
    instructions[0xE6] = std::make_unique<Opcode::INC_E6>("INC dp", "INC Increment [Flags affected: n,z]", "Direct Page");
    instructions[0xEE] = std::make_unique<Opcode::INC_EE>("INC addr", "INC Increment [Flags affected: n,z]", "Absolute");
    instructions[0xF6] = std::make_unique<Opcode::INC_F6>("INC dp,X", "INC Increment [Flags affected: n,z]", "Direct Page Indexed, X");
    instructions[0xFE] = std::make_unique<Opcode::INC_FE>("INC addr,X", "INC Increment [Flags affected: n,z]", "Absolute Indexed, X");
    instructions[0xE8] = std::make_unique<Opcode::INX_E8>("INX", "INX Increment Index Register X [Flags affected: n,z]", "Implied");
    instructions[0xC8] = std::make_unique<Opcode::INY_C8>("INY", "INY Increment Index Register Y [Flags affected: n,z]", "Implied");
    instructions[0x4C] = std::make_unique<Opcode::JMP_4C>("JMP addr", "JMP Jump [Flags affected: none][Alias: JML for all Long addressing modes]", "Absolute");
    instructions[0x5C] = std::make_unique<Opcode::JMP_5C>("JMP long", "JMP Jump [Flags affected: none][Alias: JML for all Long addressing modes]", "Absolute Long");
    instructions[0x6C] = std::make_unique<Opcode::JMP_6C>("JMP (addr)", "JMP Jump [Flags affected: none][Alias: JML for all Long addressing modes]", "Absolute Indirect");
    instructions[0x7C] = std::make_unique<Opcode::JMP_7C>("JMP (addr,X)", "JMP Jump [Flags affected: none][Alias: JML for all Long addressing modes]", "Absolute Indexed Indirect");
    instructions[0xDC] = std::make_unique<Opcode::JMP_DC>("JMP [addr]", "JMP Jump [Flags affected: none][Alias: JML for all Long addressing modes]", "Absolute Indirect Long");
    instructions[0x20] = std::make_unique<Opcode::JSR_20>("JSR addr", "JSR Jump to Subroutine [Flags affected: none][Alias: JSL for Absolute Long]", "Absolute");
    instructions[0x22] = std::make_unique<Opcode::JSR_22>("JSR long", "JSR Jump to Subroutine [Flags affected: none][Alias: JSL for Absolute Long]", "Absolute Long");
    instructions[0xFC] = std::make_unique<Opcode::JSR_FC>("JSR (addr,X)", "JSR Jump to Subroutine [Flags affected: none][Alias: JSL for Absolute Long]", "Absolute Indexed Indirect");
    instructions[0xA1] = std::make_unique<Opcode::LDA_A1>("LDA (dp,X)", "LDA Load Accumulator from Memory [Flags affected: n,z]", "Direct Page Indexed Indirect, X");
    instructions[0xA3] = std::make_unique<Opcode::LDA_A3>("LDA sr,S", "LDA Load Accumulator from Memory [Flags affected: n,z]", "Stack Relative");
    instructions[0xA5] = std::make_unique<Opcode::LDA_A5>("LDA dp", "LDA Load Accumulator from Memory [Flags affected: n,z]", "Direct Page");
    instructions[0xA7] = std::make_unique<Opcode::LDA_A7>("LDA [dp]", "LDA Load Accumulator from Memory [Flags affected: n,z]", "Direct Page Indirect Long");
    instructions[0xA9] = std::make_unique<Opcode::LDA_A9>("LDA #const", "LDA Load Accumulator from Memory [Flags affected: n,z]", "Immediate");
    instructions[0xAD] = std::make_unique<Opcode::LDA_AD>("LDA addr", "LDA Load Accumulator from Memory [Flags affected: n,z]", "Absolute");
    instructions[0xAF] = std::make_unique<Opcode::LDA_AF>("LDA long", "LDA Load Accumulator from Memory [Flags affected: n,z]", "Absolute Long");
    instructions[0xB1] = std::make_unique<Opcode::LDA_B1>("LDA (dp),Y", "LDA Load Accumulator from Memory [Flags affected: n,z]", "Direct Page Indirect Indexed, Y");
    instructions[0xB2] = std::make_unique<Opcode::LDA_B2>("LDA (dp)", "LDA Load Accumulator from Memory [Flags affected: n,z]", "Direct Page Indirect");
    instructions[0xB3] = std::make_unique<Opcode::LDA_B3>("LDA (sr,S),Y", "LDA Load Accumulator from Memory [Flags affected: n,z]", "Stack Relative Indirect Indexed, Y");
    instructions[0xB5] = std::make_unique<Opcode::LDA_B5>("LDA dp,X", "LDA Load Accumulator from Memory [Flags affected: n,z]", "Direct Page Indexed, X");
    instructions[0xB7] = std::make_unique<Opcode::LDA_B7>("LDA [dp],Y", "LDA Load Accumulator from Memory [Flags affected: n,z]", "Direct Page Indirect Long Indexed, Y");
    instructions[0xB9] = std::make_unique<Opcode::LDA_B9>("LDA addr,Y", "LDA Load Accumulator from Memory [Flags affected: n,z]", "Absolute Indexed, Y");
    instructions[0xBD] = std::make_unique<Opcode::LDA_BD>("LDA addr,X", "LDA Load Accumulator from Memory [Flags affected: n,z]", "Absolute Indexed, X");
    instructions[0xBF] = std::make_unique<Opcode::LDA_BF>("LDA long,X", "LDA Load Accumulator from Memory [Flags affected: n,z]", "Absolute Long Indexed, X");
    instructions[0xA2] = std::make_unique<Opcode::LDX_A2>("LDX #const", "LDX Load Index Register X from Memory [Flags affected: n,z]", "Immediate");
    instructions[0xA6] = std::make_unique<Opcode::LDX_A6>("LDX dp", "LDX Load Index Register X from Memory [Flags affected: n,z]", "Direct Page");
    instructions[0xAE] = std::make_unique<Opcode::LDX_AE>("LDX addr", "LDX Load Index Register X from Memory [Flags affected: n,z]", "Absolute");
    instructions[0xB6] = std::make_unique<Opcode::LDX_B6>("LDX dp,Y", "LDX Load Index Register X from Memory [Flags affected: n,z]", "Direct Page Indexed, Y");
    instructions[0xBE] = std::make_unique<Opcode::LDX_BE>("LDX addr,Y", "LDX Load Index Register X from Memory [Flags affected: n,z]", "Absolute Indexed, Y");
    instructions[0xA0] = std::make_unique<Opcode::LDY_A0>("LDY #const", "LDY Load Index Register Y from Memory [Flags affected: n,z]", "Immediate");
    instructions[0xA4] = std::make_unique<Opcode::LDY_A4>("LDY dp", "LDY Load Index Register Y from Memory [Flags affected: n,z]", "Direct Page");
    instructions[0xAC] = std::make_unique<Opcode::LDY_AC>("LDY addr", "LDY Load Index Register Y from Memory [Flags affected: n,z]", "Absolute");
    instructions[0xB4] = std::make_unique<Opcode::LDY_B4>("LDY dp,X", "LDY Load Index Register Y from Memory [Flags affected: n,z]", "Direct Page Indexed, X");
    instructions[0xBC] = std::make_unique<Opcode::LDY_BC>("LDY addr,X", "LDY Load Index Register Y from Memory [Flags affected: n,z]", "Absolute Indexed, X");
    instructions[0x46] = std::make_unique<Opcode::LSR_46>("LSR dp", "LSR Logical Shift Memory or Accumulator Right [Flags affected: n,z,c]", "Direct Page");
    instructions[0x4A] = std::make_unique<Opcode::LSR_4A>("LSR A", "LSR Logical Shift Memory or Accumulator Right [Flags affected: n,z,c]", "Accumulator");
    instructions[0x4E] = std::make_unique<Opcode::LSR_4E>("LSR addr", "LSR Logical Shift Memory or Accumulator Right [Flags affected: n,z,c]", "Absolute");
    instructions[0x56] = std::make_unique<Opcode::LSR_56>("LSR dp,X", "LSR Logical Shift Memory or Accumulator Right [Flags affected: n,z,c]", "Direct Page Indexed, X");
    instructions[0x5E] = std::make_unique<Opcode::LSR_5E>("LSR addr,X", "LSR Logical Shift Memory or Accumulator Right [Flags affected: n,z,c]", "Absolute Indexed, X");
    instructions[0x54] = std::make_unique<Opcode::MVN_54>("MVN srcbk,destbk", "MVN Block Move Negative [Flags affected: none][Registers: X,Y,C]", "Block Move");
    instructions[0x44] = std::make_unique<Opcode::MVN_44>("MVN srcbk,destbk", "MVP Block Move Positive [Flags affected: none][Registers: X,Y,C]", "Block Move");
    instructions[0xEA] = std::make_unique<Opcode::NOP_EA>("NOP", "NOP No Operation [Flags affected: none]", "Implied");
    instructions[0x01] = std::make_unique<Opcode::ORA_01>("ORA (dp,X)", "ORA OR Accumulator with Memory [Flags affected: n,z]", "Direct Page Indexed Indirect, X");
    instructions[0x03] = std::make_unique<Opcode::ORA_03>("ORA sr,S", "ORA OR Accumulator with Memory [Flags affected: n,z]", "Stack Relative");
    instructions[0x05] = std::make_unique<Opcode::ORA_05>("ORA dp", "ORA OR Accumulator with Memory [Flags affected: n,z]", "Direct Page");
    instructions[0x07] = std::make_unique<Opcode::ORA_07>("ORA [dp]", "ORA OR Accumulator with Memory [Flags affected: n,z]", "Direct Page Indirect Long");
    instructions[0x09] = std::make_unique<Opcode::ORA_09>("ORA #const", "ORA OR Accumulator with Memory [Flags affected: n,z]", "Immediate");
    instructions[0x0D] = std::make_unique<Opcode::ORA_0D>("ORA addr", "ORA OR Accumulator with Memory [Flags affected: n,z]", "Absolute");
    instructions[0x0F] = std::make_unique<Opcode::ORA_0F>("ORA long", "ORA OR Accumulator with Memory [Flags affected: n,z]", "Absolute Long");
    instructions[0x11] = std::make_unique<Opcode::ORA_11>("ORA (dp),Y", "ORA OR Accumulator with Memory [Flags affected: n,z]", "Direct Page Indirect Indexed, Y");
    instructions[0x12] = std::make_unique<Opcode::ORA_12>("ORA (dp)", "ORA OR Accumulator with Memory [Flags affected: n,z]", "Direct Page Indirect");
    instructions[0x13] = std::make_unique<Opcode::ORA_13>("ORA (sr,S),Y", "ORA OR Accumulator with Memory [Flags affected: n,z]", "Stack Relative Indirect Indexed, Y");
    instructions[0x15] = std::make_unique<Opcode::ORA_15>("ORA dp,X", "ORA OR Accumulator with Memory [Flags affected: n,z]", "Direct Page Indexed, X");
    instructions[0x17] = std::make_unique<Opcode::ORA_17>("ORA [dp],Y", "ORA OR Accumulator with Memory [Flags affected: n,z]", "Direct Page Indirect Long Indexed, Y");
    instructions[0x19] = std::make_unique<Opcode::ORA_19>("ORA addr,Y", "ORA OR Accumulator with Memory [Flags affected: n,z]", "Absolute Indexed, Y");
    instructions[0x1D] = std::make_unique<Opcode::ORA_1D>("ORA addr,X", "ORA OR Accumulator with Memory [Flags affected: n,z]", "Absolute Indexed, X");
    instructions[0x1F] = std::make_unique<Opcode::ORA_1F>("ORA long,X", "ORA OR Accumulator with Memory [Flags affected: n,z]", "Absolute Long Indexed, X");
    instructions[0xF4] = std::make_unique<Opcode::PEA_F4>("PEA addr", "PEA Push Effective Absolute Address [Flags affected: none]", "Stack (Absolute)");
    instructions[0xD4] = std::make_unique<Opcode::PEI_D4>("PEI (dp)", "PEI Push Effective Indirect Address [Flags affected: none]", "Stack (Direct Page Indirect)");
    instructions[0x62] = std::make_unique<Opcode::PER_62>("PER label", "PER Push Effective Program Counter Relative Indirect Address [Flags affected: none]", "Stack (Program Counter Relative Long)");
    instructions[0x48] = std::make_unique<Opcode::PHA_48>("PHA", "PHA Push Accumulator [Flags affected: none]", "Stack (Push)");
    instructions[0x8B] = std::make_unique<Opcode::PHB_8B>("PHB", "PHB Push Data Bank Register [Flags affected: none]", "Stack (Push)");
    instructions[0x0B] = std::make_unique<Opcode::PHD_0B>("PHD", "PHD Push Direct Page Register [Flags affected: none]", "Stack (Push)");
    instructions[0x4B] = std::make_unique<Opcode::PHK_4B>("PHK", "PHK Push Program Bank Register [Flags affected: none]", "Stack (Push)");
    instructions[0x08] = std::make_unique<Opcode::PHP_08>("PHP", "PHP Push Processor Status Register [Flags affected: none]", "Stack (Push)");
    instructions[0xDA] = std::make_unique<Opcode::PHX_DA>("PHX", "PHX Push Index Register X [Flags affected: none]", "Stack (Push)");
    instructions[0x5A] = std::make_unique<Opcode::PHY_5A>("PHY", "PHY Push Index Register Y [Flags affected: none]", "Stack (Push)");
    instructions[0x68] = std::make_unique<Opcode::PLA_68>("PLA", "PLA Pull Accumulator [Flags affected: n,z]", "Stack (Pull)");
    instructions[0xAB] = std::make_unique<Opcode::PLB_AB>("PLB", "PLB Pull Data Bank Register [Flags affected: n,z]", "Stack (Pull)");
    instructions[0x2B] = std::make_unique<Opcode::PLD_2B>("PLD", "PLD Pull Direct Page Register [Flags affected: n,z]", "Stack (Pull)");
    instructions[0x28] = std::make_unique<Opcode::PLP_28>("PLP", "PLP Pull Processor Status Register [Flags affected: n,z]", "Stack (Pull)");
    instructions[0xFA] = std::make_unique<Opcode::PLX_FA>("PLX", "PLX Pull Index Register X [Flags affected: n,z]", "Stack (Pull)");
    instructions[0x7A] = std::make_unique<Opcode::PLY_7A>("PLY", "PLY Pull Index Register Y [Flags affected: n,z]", "Stack (Pull)");
    instructions[0xC2] = std::make_unique<Opcode::REP_C2>("REP #const", "REP Reset Processor Status Bits [Flags affected: all except b per operand]", "Immediate");
    instructions[0x26] = std::make_unique<Opcode::ROL_26>("ROL dp", "ROL Rotate Memory or Accumulator Left [Flags affected: n,z,c]", "Direct Page");
    instructions[0x2A] = std::make_unique<Opcode::ROL_2A>("ROL A", "ROL Rotate Memory or Accumulator Left [Flags affected: n,z,c]", "Accumulator");
    instructions[0x2E] = std::make_unique<Opcode::ROL_2E>("ROL addr", "ROL Rotate Memory or Accumulator Left [Flags affected: n,z,c]", "Absolute");
    instructions[0x36] = std::make_unique<Opcode::ROL_36>("ROL dp,X", "ROL Rotate Memory or Accumulator Left [Flags affected: n,z,c]", "Direct Page Indexed, X");
    instructions[0x3E] = std::make_unique<Opcode::ROL_3E>("ROL addr,X", "ROL Rotate Memory or Accumulator Left [Flags affected: n,z,c]", "Absolute Indexed, X");
    instructions[0x66] = std::make_unique<Opcode::ROR_66>("ROR dp", "ROR Rotate Memory or Accumulator Right [Flags affected: n,z,c]", "Direct Page");
    instructions[0x6A] = std::make_unique<Opcode::ROR_6A>("ROR A", "ROR Rotate Memory or Accumulator Right [Flags affected: n,z,c]", "Accumulator");
    instructions[0x6E] = std::make_unique<Opcode::ROR_6E>("ROR addr", "ROR Rotate Memory or Accumulator Right [Flags affected: n,z,c]", "Absolute");
    instructions[0x76] = std::make_unique<Opcode::ROR_76>("ROR dp,X", "ROR Rotate Memory or Accumulator Right [Flags affected: n,z,c]", "Direct Page Indexed, X");
    instructions[0x7E] = std::make_unique<Opcode::ROR_7E>("ROR addr,X", "ROR Rotate Memory or Accumulator Right [Flags affected: n,z,c]", "Absolute Indexed, X");
    instructions[0x40] = std::make_unique<Opcode::RTI_40>("RTI", "RTI Return from Interrupt [Flags affected: all except b]", "Stack (RTI)");
    instructions[0x6B] = std::make_unique<Opcode::RTL_6B>("RTL", "RTL Return from Subroutine Long [Flags affected: none]", "Stack (RTL)");
    instructions[0x60] = std::make_unique<Opcode::RTS_60>("RTS", "RTS Return from Subroutine [Flags affected: none]", "Stack (RTS)");
    instructions[0xE1] = std::make_unique<Opcode::SBC_E1>("SBC (dp,X)", "SBC Subtract with Borrow from Accumulator [Flags affected: n,v,z,c]", "Direct Page Indexed Indirect, X");
    instructions[0xE3] = std::make_unique<Opcode::SBC_E3>("SBC sr,S", "SBC Subtract with Borrow from Accumulator [Flags affected: n,v,z,c]", "Stack Relative");
    instructions[0xE5] = std::make_unique<Opcode::SBC_E5>("SBC dp", "SBC Subtract with Borrow from Accumulator [Flags affected: n,v,z,c]", "Direct Page");
    instructions[0xE7] = std::make_unique<Opcode::SBC_E7>("SBC [dp]", "SBC Subtract with Borrow from Accumulator [Flags affected: n,v,z,c]", "Direct Page Indirect Long");
    instructions[0xE9] = std::make_unique<Opcode::SBC_E9>("SBC #const", "SBC Subtract with Borrow from Accumulator [Flags affected: n,v,z,c]", "Immediate");
    instructions[0xED] = std::make_unique<Opcode::SBC_ED>("SBC addr", "SBC Subtract with Borrow from Accumulator [Flags affected: n,v,z,c]", "Absolute");
    instructions[0xEF] = std::make_unique<Opcode::SBC_EF>("SBC long", "SBC Subtract with Borrow from Accumulator [Flags affected: n,v,z,c]", "Absolute Long");
    instructions[0xF1] = std::make_unique<Opcode::SBC_F1>("SBC (dp),Y", "SBC Subtract with Borrow from Accumulator [Flags affected: n,v,z,c]", "Direct Page Indirect Indexed, Y");
    instructions[0xF2] = std::make_unique<Opcode::SBC_F2>("SBC (dp)", "SBC Subtract with Borrow from Accumulator [Flags affected: n,v,z,c]", "Direct Page Indirect");
    instructions[0xF3] = std::make_unique<Opcode::SBC_F3>("SBC (sr,S),Y", "SBC Subtract with Borrow from Accumulator [Flags affected: n,v,z,c]", "Stack Relative Indirect Indexed, Y");
    instructions[0xF5] = std::make_unique<Opcode::SBC_F5>("SBC dp,X", "SBC Subtract with Borrow from Accumulator [Flags affected: n,v,z,c]", "Direct Page Indexed, X");
    instructions[0xF7] = std::make_unique<Opcode::SBC_F7>("SBC [dp],Y", "SBC Subtract with Borrow from Accumulator [Flags affected: n,v,z,c]", "Direct Page Indirect Long Indexed, Y");
    instructions[0xF9] = std::make_unique<Opcode::SBC_F9>("SBC addr,Y", "SBC Subtract with Borrow from Accumulator [Flags affected: n,v,z,c]", "Absolute Indexed, Y");
    instructions[0xFD] = std::make_unique<Opcode::SBC_FD>("SBC addr,X", "SBC Subtract with Borrow from Accumulator [Flags affected: n,v,z,c]", "Absolute Indexed, X");
    instructions[0xFF] = std::make_unique<Opcode::SBC_FF>("SBC long,X", "SBC Subtract with Borrow from Accumulator [Flags affected: n,v,z,c]", "Absolute Long Indexed, X");
    instructions[0x38] = std::make_unique<Opcode::SEC_38>("SEC", "SEC Set Carry Flag [Flags affected: c]", "Implied");
    instructions[0xF8] = std::make_unique<Opcode::SED_F8>("SED", "SED Set Decimal Flag [Flags affected: d]", "Implied");
    instructions[0x78] = std::make_unique<Opcode::SEI_78>("SEI", "SEI Set Interrupt Disable Flag [Flags affected: i]", "Implied");
    instructions[0xE2] = std::make_unique<Opcode::SEP_E2>("SEP #const", "SEP Set Processor Status Bits [Flags affected: all except b per operand]", "Immediate");
    instructions[0x81] = std::make_unique<Opcode::STA_81>("STA (dp,X)", "STA Store Accumulator to Memory [Flags affected: none]", "Direct Page Indexed Indirect, X");
    instructions[0x83] = std::make_unique<Opcode::STA_83>("STA sr,S", "STA Store Accumulator to Memory [Flags affected: none]", "Stack Relative");
    instructions[0x85] = std::make_unique<Opcode::STA_85>("STA dp", "STA Store Accumulator to Memory [Flags affected: none]", "Direct Page");
    instructions[0x87] = std::make_unique<Opcode::STA_87>("STA [dp]", "STA Store Accumulator to Memory [Flags affected: none]", "Direct Page Indirect Long");
    instructions[0x8D] = std::make_unique<Opcode::STA_8D>("STA addr", "STA Store Accumulator to Memory [Flags affected: none]", "Absolute");
    instructions[0x8F] = std::make_unique<Opcode::STA_8F>("STA long", "STA Store Accumulator to Memory [Flags affected: none]", "Absolute Long");
    instructions[0x91] = std::make_unique<Opcode::STA_91>("STA (dp),Y", "STA Store Accumulator to Memory [Flags affected: none]", "Direct Page Indirect Indexed, Y");
    instructions[0x92] = std::make_unique<Opcode::STA_92>("STA (dp)", "STA Store Accumulator to Memory [Flags affected: none]", "Direct Page Indirect");
    instructions[0x93] = std::make_unique<Opcode::STA_93>("STA (sr,S),Y", "STA Store Accumulator to Memory [Flags affected: none]", "Stack Relative Indirect Indexed, Y");
    instructions[0x95] = std::make_unique<Opcode::STA_95>("STA dp,X", "STA Store Accumulator to Memory [Flags affected: none]", "Direct Page Indexed, X");
    instructions[0x97] = std::make_unique<Opcode::STA_97>("STA [dp],Y", "STA Store Accumulator to Memory [Flags affected: none]", "Direct Page Indirect Long Indexed, Y");
    instructions[0x99] = std::make_unique<Opcode::STA_99>("STA addr,Y", "STA Store Accumulator to Memory [Flags affected: none]", "Absolute Indexed, Y");
    instructions[0x9D] = std::make_unique<Opcode::STA_9D>("STA addr,X", "STA Store Accumulator to Memory [Flags affected: none]", "Absolute Indexed, X");
    instructions[0x9F] = std::make_unique<Opcode::STA_9F>("STA long,X", "STA Store Accumulator to Memory [Flags affected: none]", "Absolute Long Indexed, X");
    instructions[0xDB] = std::make_unique<Opcode::STP_DB>("STP", "STP Stop Processor [Flags affected: none]", "Implied");
    instructions[0x86] = std::make_unique<Opcode::STX_86>("STX dp", "STX Store Index Register X to Memory [Flags affected: none]", "Direct Page");
    instructions[0x8E] = std::make_unique<Opcode::STX_8E>("STX addr", "STX Store Index Register X to Memory [Flags affected: none]", "Absolute");
    instructions[0x96] = std::make_unique<Opcode::STX_96>("STX dp,Y", "STX Store Index Register X to Memory [Flags affected: none]", "Direct Page Indexed, Y");
    instructions[0x84] = std::make_unique<Opcode::STY_84>("STY dp", "STY Store Index Register Y to Memory [Flags affected: none]", "Direct Page");
    instructions[0x8C] = std::make_unique<Opcode::STY_8C>("STY addr", "STY Store Index Register Y to Memory [Flags affected: none]", "Absolute");
    instructions[0x94] = std::make_unique<Opcode::STY_94>("STY dp,X", "STY Store Index Register Y to Memory [Flags affected: none]", "Direct Page Indexed, X");
    instructions[0x64] = std::make_unique<Opcode::STZ_64>("STZ dp", "STZ Store Zero to Memory [Flags affected: none]", "Direct Page");
    instructions[0x74] = std::make_unique<Opcode::STZ_74>("STZ dp,X", "STZ Store Zero to Memory [Flags affected: none]", "Direct Page Indexed, X");
    instructions[0x9C] = std::make_unique<Opcode::STZ_9C>("STZ addr", "STZ Store Zero to Memory [Flags affected: none]", "Absolute");
    instructions[0x9E] = std::make_unique<Opcode::STZ_9E>("STZ addr,X", "STZ Store Zero to Memory [Flags affected: none]", "Absolute Indexed, X");
    instructions[0xAA] = std::make_unique<Opcode::TAX_AA>("TAX", "TAX Transfer Accumulator to Index Register X [Flags affected: n,z]", "Implied");
    instructions[0xA8] = std::make_unique<Opcode::TAY_A8>("TAY", "TAY Transfer Accumulator to Index Register Y [Flags affected: n,z]", "Implied");
    instructions[0x5B] = std::make_unique<Opcode::TCD_5B>("TCD", "TCD Transfer 16-bit Accumulator to Direct Page Register [Flags affected: n,z]", "Implied");
    instructions[0x1B] = std::make_unique<Opcode::TCS_1B>("TCS", "TCS Transfer 16-bit Accumulator to Stack Pointer [Flags affected: none]", "Implied");
    instructions[0x7B] = std::make_unique<Opcode::TDC_7B>("TDC", "TDC Transfer Direct Page Register to 16-bit Accumulator [Flags affected: n,z]", "Implied");
    instructions[0x14] = std::make_unique<Opcode::TRB_14>("TRB dp", "TRB Test and Reset Memory Bits Against Accumulator [Flags affected: z]", "Direct Page");
    instructions[0x1C] = std::make_unique<Opcode::TRB_1C>("TRB addr", "TRB Test and Reset Memory Bits Against Accumulator [Flags affected: z]", "Absolute");
    instructions[0x04] = std::make_unique<Opcode::TSB_04>("TSB dp", "TSB Test and Set Memory Bits Against Accumulator [Flags affected: z]", "Direct Page");
    instructions[0x0C] = std::make_unique<Opcode::TSB_0C>("TSB addr", "TSB Test and Set Memory Bits Against Accumulator [Flags affected: z]", "Absolute");
    instructions[0x3B] = std::make_unique<Opcode::TSC_3B>("TSC", "TSC Transfer Stack Pointer to 16-bit Accumulator [Flags affected: n,z]", "Implied");
    instructions[0xBA] = std::make_unique<Opcode::TSX_BA>("TSX", "TSX Transfer Stack Pointer to Index Register X [Flags affected: n,z]", "Implied");
    instructions[0x8A] = std::make_unique<Opcode::TXA_8A>("TXA", "TXA Transfer Index Register X to Accumulator [Flags affected: n,z]", "Implied");
    instructions[0x9A] = std::make_unique<Opcode::TXS_9A>("TXS", "TXS Transfer Index Register X to Stack Pointer [Flags affected: none]", "Implied");
    instructions[0x9B] = std::make_unique<Opcode::TXY_9B>("TXY", "TXY Transfer Index Register X to Index Register Y [Flags affected: n,z]", "Implied");
    instructions[0x98] = std::make_unique<Opcode::TYA_98>("TYA", "TYA Transfer Index Register Y to Accumulator [Flags affected: n,z]", "Implied");
    instructions[0xBB] = std::make_unique<Opcode::TYX_BB>("TYX", "TYX Transfer Index Register Y to Index Register X [Flags affected: n,z]", "Implied");
    instructions[0xCB] = std::make_unique<Opcode::WAI_CB>("WAI", "WAI Wait for Interrupt [Flags affected: none]", "Implied");
    instructions[0x42] = std::make_unique<Opcode::WDM_42>("WDM", "WDM Reserved for Future Expansion [Flags affected: none (subject to change)]", "n/a");
    instructions[0xEB] = std::make_unique<Opcode::XBA_EB>("XBA", "XBA Exchange B and A 8-bit Accumulators [Flags affected: n,z]", "Implied");
    instructions[0xFB] = std::make_unique<Opcode::XCE_FB>("XCE", "XCE Exchange Carry and Emulation Flags [Flags affected: m,b/x,c,e]", "Implied");
}
